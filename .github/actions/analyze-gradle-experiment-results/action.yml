name: Analyze Gradle experiment results
description: Analyze Gradle experiment results from the Develocity Build Validation Scripts

inputs:
  develocityApiKey:
    description: Develocity API key or token with API permissions.
    required: true
  geminiApiKey:
    description: Gemini API key.
    required: true
  buildScanExperiment1:
    description: Build Scan URL for the second build from experiment 1.
    required: false
  buildScanExperiment2:
    description: Build Scan URL for the second build from experiment 2.
    required: false
  buildScanExperiment3:
    description: Build Scan URL for the second build from experiment 3.
    required: false

runs:
  using: composite
  steps:
    - name: Fetch results
      id: fetch-results
      shell: bash
      env:
        BUILD_SCAN_EXP1: ${{ inputs.buildScanExperiment1 }}
        BUILD_SCAN_EXP2: ${{ inputs.buildScanExperiment2 }}
        BUILD_SCAN_EXP3: ${{ inputs.buildScanExperiment3 }}
        DEVELOCITY_API_KEY: ${{ inputs.develocityApiKey }}
      run: |
        echo "::warning title=Experimental action usage::The action `gradle/develocity-oss-projects/.github/actions/analyze-gradle-experiment-results` is experimental and not intended for use outside of [gradle/develocity-oss-projects](https://github.com/gradle/develocity-oss-projects)."
        
        capture_results() {
          local experiment build_scan_url develocity_server build_scan_id results previous_results executed_tasks executed_cacheable_tasks
          experiment="$1"
          build_scan_url="$2"
        
          if [[ -n "$build_scan_url" ]]; then
            develocity_server="$(echo "$build_scan_url" | cut -d'/' -f1,2,3)"
            build_scan_id="$(extract_build_scan_id "$build_scan_url")"
            results="$(fetch_results "$develocity_server" "$build_scan_id")"
            previous_results="$(fetch_previous_results "$develocity_server" "$results")"
        
            executed_tasks="$(echo "$results" | jq --raw-output '.models.gradleBuildCachePerformance.model.taskExecution | map(select(.avoidanceOutcome == "executed_cacheable" or .avoidanceOutcome == "executed_not_cacheable")) | length')"
            executed_cacheable_tasks="$(echo "$results" | jq --raw-output '.models.gradleBuildCachePerformance.model.taskExecution | map(select(.avoidanceOutcome == "executed_cacheable")) | length')"
        
            echo "${experiment}-results=$results" >> "$GITHUB_OUTPUT"
            echo "${experiment}-previous-results=$previous_results" >> "$GITHUB_OUTPUT"
            echo "${experiment}-executed-tasks=$executed_tasks" >> "$GITHUB_OUTPUT"
            echo "${experiment}-executed-cacheable-tasks=$executed_cacheable_tasks" >> "$GITHUB_OUTPUT"
          else
            echo "${experiment}-results=This experiment didn't yield any results. The job may have failed." >> "$GITHUB_OUTPUT"
          fi
        }
        
        extract_build_scan_id() {
          echo "$1" | rev | cut -d'/' -f1 | rev
        }
        
        fetch_results() {
          local develocity_server build_scan_id
          develocity_server="$1"
          build_scan_id="$2"
        
          curl -s \
            -H "Authorization: Bearer $DEVELOCITY_API_KEY" \
            "$develocity_server/api/builds/$build_scan_id?models=gradle-attributes&models=gradle-build-cache-performance"
        }
        
        fetch_previous_results() {
          local develocity_server results project experiment_id experiment_run_id
          develocity_server="$1"
          results="$2"
        
          project="$(echo "$results" | jq --raw-output '.models.gradleAttributes.model.rootProjectName')"
          experiment_id="$(echo "$results" | jq --raw-output '.models.gradleAttributes.model.values[] | select(.name == "Experiment id").value')"
          experiment_run_id="$(echo "$results" | jq --raw-output '.models.gradleAttributes.model.values[] | select(.name == "Experiment run id").value')"
        
          curl -s \
            -H "Authorization: Bearer $DEVELOCITY_API_KEY" \
            "$develocity_server/api/builds?reverse=true&maxBuilds=1&models=gradle-attributes&models=gradle-build-cache-performance&query=project%3A%22${project}%22%20tag%3A%22${experiment_id}%22%20-value%3A%22Experiment%20run%20id%3D${experiment_run_id}%22"
        }
        
        capture_results exp1 "$BUILD_SCAN_EXP1"
        capture_results exp2 "$BUILD_SCAN_EXP2"
        capture_results exp3 "$BUILD_SCAN_EXP3"
    - name: Summarize experiment 1 results
      id: summarize-exp1
      if: steps.fetch-results.outputs.exp1-executed-tasks != '0' && inputs.buildScanExperiment1 != null
      uses: google-github-actions/run-gemini-cli@v0.1.13
      with:
        gemini_api_key: ${{ inputs.geminiApiKey }}
        prompt: |
          ### Persona
          
          You are a Develocity Solutions Engineer, an expert specializing in build performance optimization for Gradle and Maven.
          Your tone is knowledgeable, helpful, and precise.
          You are a trusted advisor whose goal is to provide clear, actionable insights that help developers improve their build efficiency.
          
          ### Context
          
          You will be analyzing experiment results from the Develocity Build Validation Scripts.
          This specific experiment is designed to identify tasks with volatile inputs or non-deterministic outputsâ€”common reasons builds fail to leverage Gradle's incremental building (up-to-date checking) optimization even when no code has changed.
          
          The experiment operates in two stages:
          
          Build 1: A clean build runs to populate build outputs.
          Build 2: An identical build is run immediately afterward in the same location.
          
          Your analysis is based on the build performance output from the Develocity API for Build 2.
          Ideally, all tasks in this second build should be up-to-date.
          The core problem you are looking for is when tasks are re-executed, which indicates their inputs changed unexpectedly or their outputs were not deterministic.
          
          While the primary purpose is to uncover tasks with volatile inputs (e.g., timestamps) or non-deterministic outputs (e.g., unstable file ordering), it cannot be definitively guaranteed that this is the cause.
          Your diagnosis should present this as the most probable cause, prompting investigation rather than stating it as an absolute fact.
          
          ### Task
          
          Your task is to analyze the provided JSON from the second build and generate a concise report that helps a developer understand and fix the underlying caching issues.
          
          Your report must:
          
          1. Identify problematic tasks: Pinpoint the specific tasks that were re-executed. Look for tasks in the `taskExecution` array where the `avoidanceOutcome` is `executed_cacheable` or `executed_not_cacheable`, using the `taskPath` to identify them.
          2. Diagnose the likely root cause: Explain that the most probable reason for re-execution is volatile inputs (like a timestamp) or non-deterministic outputs that change between builds.
          3. Quantify the impact: Calculate the total potential time savings by summing the duration (in milliseconds) for every task where the `avoidanceOutcome` is `executed_cacheable` or `executed_not_cacheable`.
          4. Provide actionable recommendations: Give a clear, direct recommendation to investigate the task inputs for sources of volatility and to check the task's implementation for non-deterministic logic.
          
          ### Format
          
          Structure your response in Markdown with the following clear sections:
          
          ```
          #### Problematic tasks
          
          [A bulleted list of the taskPath values for tasks that were executed_cacheable or executed_not_cacheable]
          
          #### Likely root cause
          
          [A brief paragraph explaining the most probable reason these tasks were re-executed]
          
          #### Potential savings
          
          [A short sentence stating the time that could be saved]
          
          #### Recommendation
          
          [A clear paragraph outlining the next steps the user should take]
          ```
          
          ### Exemplar
          
          Given this input JSON snippet:
          
          ```
          {
            "taskExecution": [
              {
                "taskPath": ":feature-login:compileJava",
                "taskType": "org.gradle.api.tasks.compile.JavaCompile",
                "avoidanceOutcome": "avoided_up_to_date",
                "duration": 15000
              },
              {
                "taskPath": ":core-utils:compileJava",
                "taskType": "org.gradle.api.tasks.compile.JavaCompile",
                "avoidanceOutcome": "executed_cacheable",
                "duration": 20000
              },
              {
                "taskPath": ":core-utils:processResources",
                "taskType": "org.gradle.language.jvm.tasks.ProcessResources",
                "avoidanceOutcome": "executed_not_cacheable",
                "duration": 18000
              }
            ]
          }
          ```
          
          Your output should look like this:
          
          ```
          #### Problematic tasks
          
          * `:core-utils:compileJava`
          * `:core-utils:processResources`
          
          #### Likely root cause
          
          The most likely reason these tasks were re-executed on a subsequent build is due to unstable inputs or non-deterministic outputs. This often happens if a task's inputs include volatile information like a timestamp, or if a task generates outputs (like code or resource files) in a non-repeatable order, causing input fingerprints to change unexpectedly.
          
          #### Potential savings
          
          By addressing these caching issues, you could save up to 38 seconds in build time, which was the total duration of the re-executed tasks.
          
          #### Recommendation
          
          You should investigate the inputs for the listed tasks to identify any sources of volatility, such as timestamps or dynamically generated content that is not stable. Also, review the tasks' logic for any non-deterministic behavior that could cause their outputs to change between identical runs. Making the inputs and outputs stable is key to ensuring these tasks can leverage Gradle's incremental building optimization.
          ```
          
          ---
          
          Now, analyze the following build data and generate the report as instructed:
          
          ```
          ${{ steps.fetch-results.outputs.exp1-results }}
          ```
    - name: Summarize experiment 2 results
      id: summarize-exp2
      if: steps.fetch-results.outputs.exp2-executed-cacheable-tasks != '0' && inputs.buildScanExperiment2 != null
      uses: google-github-actions/run-gemini-cli@v0.1.13
      with:
        gemini_api_key: ${{ inputs.geminiApiKey }}
        prompt: |
          ### Persona
          
          You are a Develocity Solutions Engineer, an expert specializing in build performance optimization for Gradle and Maven.
          Your tone is knowledgeable, helpful, and precise.
          You are a trusted advisor whose goal is to provide clear, actionable insights that help developers improve their build efficiency.
          
          ### Context
          
          You will be analyzing the results of multiple Develocity Build Validation experiments.
          While data from several experiments may be provided, your primary focus is to analyze the results of Experiment 2.

          Here is the context for the relevant experiments:
          
          - Experiment 2: Runs the build twice from the same directory. A task with an `executed_cacheable` outcome in this experiment likely has volatile inputs (e.g., timestamps) or non-deterministic outputs.
          - Experiment 3: Runs the build twice from different directories. A task with an `executed_cacheable` in this experiment likely has non-relocatable inputs (e.g., absolute file paths).
          
          Your analysis is based on the build performance output from the Develocity API for the second build.
          Ideally, all cacheable tasks in this second build should be pulled from the cache.
          The core problem you are looking for is when cacheable tasks are re-executed, which indicates their inputs changed unexpectedly or their outputs were not deterministic.
          
          Your unique task is to use the results from Experiment 3 to make a more intelligent diagnosis of the executed cacheable tasks in Experiment 2.
          The core analytical logic is as follows:
          
          - If a task is `from_cache` in Experiment 3 but was `executed_cacheable` in Experiment 2, the problem is almost certainly caused by a later task in the first build dirtying the workspace (e.g., generating sources to one of the task's input directories), while still remaining relocatable.
          - If a task is `executed_cacheable` in both Experiment 2 and Experiment 3, the root cause is ambiguous. It could suffer from non-relocatable inputs, volatile inputs, or both.
          
          ### Task
          
          Your task is to analyze the provided JSON from Experiment 2, using the data from Experiment 3 as context. Your report must:
          
          Your report must:
          
          1. Identify problematic tasks: Pinpoint tasks from Experiment 2 where the `avoidanceOutcome` is `executed_cacheable`, using the `taskPath` to identify them. Do not analyze tasks with other outcomes.
          2. Diagnose the likely root cause: Explain that the most probable reason for re-execution is volatile inputs (like a timestamp) or non-deterministic outputs that change between builds.
          3. Quantify the impact: Calculate the total potential time savings by summing the duration (in milliseconds) for every task where the `avoidanceOutcome` is `executed_cacheable`.
          4. Provide actionable recommendations: Give a clear, direct recommendation to investigate the task inputs for sources of volatility and to check the task's implementation for non-deterministic logic.
          
          ### Format
          
          Structure your response in Markdown with the following clear sections:
          
          ```
          #### Problematic tasks
          
          [A bulleted list of the taskPath values for tasks that were executed_cacheable]
          
          #### Likely root cause
          
          [A brief paragraph explaining the most probable reason these tasks were re-executed]
          
          #### Potential savings
          
          [A short sentence stating the time that could be saved]
          
          #### Recommendation
          
          [A clear paragraph outlining the next steps the user should take]
          ```
          
          ### Exemplar
          
          Given these input JSON snippets:

          Experiment 3 results:

          ```
          {
            "taskExecution": [
              { "taskPath": ":feature-login:compileJava", "avoidanceOutcome": "from_cache" },
              { "taskPath": ":core-utils:compileJava", "avoidanceOutcome": "executed_cacheable" }
            ]
          }
          ```
          
          Experiment 2 results:
          
          ```
          {
            "taskExecution": [
              {
                "taskPath": ":feature-login:compileJava",
                "taskType": "org.gradle.api.tasks.compile.JavaCompile",
                "avoidanceOutcome": "executed_cacheable",
                "duration": 15000
              },
              {
                "taskPath": ":core-utils:compileJava",
                "taskType": "org.gradle.api.tasks.compile.JavaCompile",
                "avoidanceOutcome": "executed_cacheable",
                "duration": 20000
              },
              {
                "taskPath": ":core-utils:processResources",
                "taskType": "org.gradle.language.jvm.tasks.ProcessResources",
                "avoidanceOutcome": "executed_not_cacheable",
                "duration": 18000
              }
            ]
          }
          ```
          
          Your output should look like this:
          
          ```
          #### Problematic tasks
          
          * `:feature-login:compileJava`
          * `:core-utils:compileJava`
          
          #### Likely root cause
          
          The analysis reveals two different types of caching issues:
          
          * The task `:feature-login:compileJava` was re-executed in Experiment 2 but was taken from the cache in Experiment 3. This strongly indicates the problem is due to a later task dirtying the workspace, e.g., generating sources to this task's `src/main/java` directory.
          * The task `:core-utils:compileJava` was re-executed in both Experiment 2 and Experiment 3. This suggests a compound issue: it suffers from volatile inputs/non-deterministic outputs and may also contain non-relocatable inputs.          
          
          #### Potential savings
          
          By addressing these caching issues, you could save up to 35 seconds in build time, which was the total duration of the re-executed cacheable tasks.
          
          #### Recommendation
          
          You should investigate the inputs for the listed tasks. For `:feature-login:compileJava`, check that a task is not writing to its input directories, e.g., `src/main/java`. For `:core-utils:compileJava`, begin by investigating volatile inputs, and then proceed to check for non-relocatable inputs like absolute paths, as it may suffer from both problems.          ```

          ---
          
          Now, analyze the following build data and generate the report as instructed:
          
          Experiment 2 results:
          
          ```
          ${{ steps.fetch-results.outputs.exp2-results }}
          ```
          
          Experiment 3 results (for additional context):
          
          ```
          ${{ steps.fetch-results.outputs.exp3-results }}
          ```
    - name: Summarize experiment 3 results
      id: summarize-exp3
      uses: google-github-actions/run-gemini-cli@v0.1.13
      if: steps.fetch-results.outputs.exp3-executed-cacheable-tasks != '0' && inputs.buildScanExperiment3 != null
      with:
        gemini_api_key: ${{ inputs.geminiApiKey }}
        prompt: |
          ### Persona
          
          You are a Develocity Solutions Engineer, an expert specializing in build performance optimization for Gradle.
          Your tone is knowledgeable, helpful, and precise.
          You are a trusted advisor whose goal is to provide clear, actionable insights that help developers improve their build efficiency.
          
          ## Context
          
          You will be analyzing the results of multiple Develocity Build Validation experiments.
          While data from several experiments may be provided, your primary focus is to analyze the results of the current Experiment 3, which tests for non-relocatable tasks.

          Here is the context for the relevant experiments:
          
          - Experiment 2 (current run): Runs the build twice from the same directory. A task with an `executed_cacheable` outcome in this experiment likely has volatile inputs (e.g., timestamps) or non-deterministic outputs.
          - Experiment 3 (current run): Runs the build twice from different directories. A task with an `executed_cacheable` in this experiment likely has non-relocatable inputs (e.g., absolute file paths).          
          - Experiment 3 (previous run): Provides a historical baseline of the project's relocatability.          

          Your analysis is based on the build performance output from the Develocity API for the second build.
          Ideally, all cacheable tasks in this second build should be pulled from the cache.
          The core problem you are looking for is when cacheable tasks are re-executed, which indicates their inputs changed unexpectedly or their outputs were not deterministic.

          Your unique task is to use the results from both Experiment 2 and the previous Experiment 3 to make a more intelligent diagnosis of the executed cacheable tasks in the current Experiment 3.
          The core analytical logic is as follows:
          
          1. Identify regressions: If a task is `executed_cacheable` in the current Experiment 3 but was `from_cache` in the previous Experiment 3, this indicates a regression that has recently broken its relocatability.
          2. Analyze current results:
            - If a task is `executed_cacheable` in the current Experiment 3 but was `from_cache` in Experiment 2, the problem is almost certainly due to non-relocatable inputs.
            - If a task is `executed_cacheable` in both the current Experiment 2 and Experiment 3, the root cause is ambiguous. It could suffer from non-relocatable inputs, volatile inputs, or both.

          ### Task

          Your task is to analyze the provided JSON from the current Experiment 3, using the other results as context. Your report must:

          - Identify problematic tasks: Pinpoint tasks from the current Experiment 3 where the `avoidanceOutcome` is `executed_cacheable`, using the `taskPath` to identify them. Do not analyze tasks with other outcomes.
          - Diagnose the likely root cause: For each problematic task, use the full cross-experiment logic to determine the most probable cause. Differentiate between regressions, non-relocatable tasks, and those with ambiguous failures.
          - Quantify the impact: Calculate the total potential time savings by summing the `duration` (in milliseconds) for every task that was `executed_cacheable` in the current Experiment 3.
          - Provide actionable recommendations: Give clear, targeted advice for each failure category.

          ### Format

          Structure your response in Markdown with the following clear sections:

          ```
          #### Problematic Tasks
          
          [A bulleted list of the taskPath values for tasks that were executed_cacheable in Experiment 3]
          
          #### Likely Root Cause
          
          [A paragraph explaining the diagnosis based on the comparison with all provided experiments. Clearly separate the different categories of failures, including regressions]
          
          #### Potential Savings
          
          [A short sentence stating the total time that could be saved based on the current Experiment 3's results]
          
          #### Recommendation
          
          [A clear paragraph outlining the next steps the user should take, tailored to the different findings]
          ```
          
          ### Exemplar

          Given these input JSON snippets:

          Experiment 2 results:

          ```
          {
            "taskExecution": [
              { "taskPath": ":feature-login:compileJava", "avoidanceOutcome": "from_cache" },
              { "taskPath": ":core-utils:compileJava", "avoidanceOutcome": "executed_cacheable" },
              { "taskPath": ":shared-ui:compileJava", "avoidanceOutcome": "from_cache" }
            ]
          }
          ```
          
          Previous Experiment 3 results:
          
          ```
          {
            "taskExecution": [
              { "taskPath": ":feature-login:compileJava", "avoidanceOutcome": "executed_cacheable" },
              { "taskPath": ":core-utils:compileJava", "avoidanceOutcome": "executed_cacheable" },
              { "taskPath": ":shared-ui:compileJava", "avoidanceOutcome": "from_cache" }
            ]
          }
          ```

          Experiment 3 Results:

          ```
          {
            "taskExecution": [
              {
                "taskPath": ":feature-login:compileJava",
                "taskType": "org.gradle.api.tasks.compile.JavaCompile",
                "avoidanceOutcome": "executed_cacheable",
                "duration": 15000
              },
              {
                "taskPath": ":core-utils:compileJava",
                "taskType": "org.gradle.api.tasks.compile.JavaCompile",
                "avoidanceOutcome": "executed_cacheable",
                "duration": 20000
              },
              {
                "taskPath": ":core-utils:processResources",
                "taskType": "org.gradle.language.jvm.tasks.ProcessResources",
                "avoidanceOutcome": "executed_not_cacheable",
                "duration": 18000
              },
              {
                "taskPath": ":shared-ui:compileJava",
                "taskType": "org.gradle.api.tasks.compile.JavaCompile",
                "avoidanceOutcome": "executed_cacheable",
                "duration": 12000
              }
            ]
          }
          ```

          Your output should look like this:

          ```
          #### Problematic tasks

          - `:feature-login:compileJava`
          - `:core-utils:compileJava`
          - `:shared-ui:compileJava`
          
          #### Likely root cause
          
          Based on a comparison across the experiments, we can diagnose the following:
          
          - **Regression:** The task `:shared-ui:compileJava` was taken from the cache in the previous run but was executed in this run. This may indicate a recent change has introduced a non-relocatable input, breaking its cacheability.
          - **Non-relocatable input:** The task `:feature-login:compileJava` was executed in this experiment but was taken from the cache in Experiment 2. This indicates that it might have a non-relocatable input, such as absolute file paths.
          - **Ambiguous cause:** The task `:core-utils:compileJava` was executed in both Experiment 2 and 3. This means it could have non-relocatable inputs, volatile inputs (like timestamps), or a combination of both issues.
          
          #### Potential savings
          
          By addressing these issues, you could save up to 47 seconds in build time, which was the total duration of the re-executed cacheable tasks in this experiment.
          
          #### Recommendation
          
          You should investigate the inputs for all three tasks. For the regression in `:shared-ui:compileJava`, focus on recent code changes to identify the cause. For `:feature-login:compileJava`, focus on finding and removing absolute paths. For `:core-utils:compileJava`, the investigation is broader; you should check for both non-relocatable inputs and sources of volatility.
          ```
          
          ---
          
          Now, analyze the following build data and generate the report as instructed:
          
          Experiment 3 results:
          
          ```
          ${{ steps.fetch-results.outputs.exp3-results }}
          ```
          
          Previous Experiment 3 results (for additional context):
          
          ```
          ${{ steps.fetch-results.outputs.exp3-previous-results }}
          ```
          
          Experiment 2 results (for additional context):
          
          ```
          ${{ steps.fetch-results.outputs.exp2-results }}
          ```
    - name: Summarize findings
      id: summarize-findings
      uses: google-github-actions/run-gemini-cli@v0.1.13
      with:
        gemini_api_key: ${{ inputs.geminiApiKey }}
        prompt: |
          ### Persona
          
          You are a Develocity Solutions Engineer, an expert specializing in build performance optimization.
          Your current role is to synthesize detailed build analysis reports into a high-level executive summary.
          Your tone is strategic, insightful, and focused on the overall health of the build.
          
          ### Context
          
          You will be provided with three separate build analysis summaries, generated from three different experiments:
          
          1. Analysis of in-place caching issues (from Experiment 1): This report identifies tasks that were re-executed rather than being up-to-date when the build was run twice in the same location and were therefore not up-to-date. This is likely caused by volatile inputs (e.g., timestamps) or non-deterministic outputs.
          2. Analysis of in-place caching issues (from Experiment 2): This report identifies tasks that were re-executed rather than being reused from the build cache when the build was run twice in the same location. These failures are likely caused by volatile inputs (e.g., timestamps) or non-deterministic outputs.
          3. Analysis of non-relocatable tasks (from Experiment 3): This report identifies tasks that were re-executed rather than being reused from the build cache when the build was run in a different location. These failures are likely caused by non-relocatable inputs (e.g., absolute file paths).
          
          ### Task
          
          Your task is to consume all analysis reports and generate a single, unified summary.
          This summary should provide a holistic view of the build's incrementality and caching performance, highlighting the different types of problems discovered and their combined impact.
          You should:
          
          1. Synthesize findings: Combine the results from all reports to explain the overall state of build cacheability.
          2. Identify overlapping issues: Point out if the same tasks are failing in two or more experiments, as this indicates there may be multiple, complex problems for a single task.
          3. Provide a unified recommendation: Create a single, prioritized list of actions based on the findings from all reports.
          
          ### Format
          
          Structure your summary in Markdown with the following clear sections:
          
          ```
          #### Key findings
          
          [A bulleted list that synthesizes the main problems from all reports]
          
          #### Recommendation
          
          [A paragraph outlining a strategic approach to fixing the identified issues, suggesting which problems to tackle first]
          ```
          
          Exemplar
          
          Given these three input reports:
          
          Experiment 1 analysis:
          
          ```
          #### Problematic tasks
          * :core-utils:compileJava
          
          #### Likely root cause
          The task was re-executed... possibly due to unstable inputs and outputs outputs...
          
          #### Potential savings
          By addressing issue, you could save up to 35 seconds in build time...
          
          #### Recommendation
          Find the the `:core-utils:compileJava` task and inspect its configuration for any signs of volatility...
          ```
          
          Experiment 2 analysis:
          
          ```
          #### Problematic tasks
          * :core-utils:compileJava
          
          #### Likely root cause
          The most likely reason this task was re-executed... is due to unstable inputs or non-deterministic outputs...
          
          #### Potential savings
          By addressing this caching issue, you could save up to 35 seconds in build time...
          
          #### Recommendation
          You should investigate the inputs for the `:core-utils:compileJava` to identify any sources of volatility...
          
          ```
          
          Experiment 3 analysis:
          
          ```          
          #### Problematic tasks
          * :feature-login:compileJava
          * :core-utils:compileJava
          
          #### Likely root cause
          ... The task `:feature-login:compileJava` was executed in this experiment but was taken from the cache in Experiment 2. This strongly indicates that it has non-relocatable inputs... The task `:core-utils:compileJava` was executed in both Experiment 2 and 3. This means it could have non-relocatable inputs, volatile inputs... or a combination of both issues.
          
          #### Potential savings
          By addressing these issues, you could save up to 35,000 ms in build time...
          
          #### Recommendation
          You should investigate the inputs for both tasks. For `:feature-login:compileJava`, focus on finding and removing absolute paths. For `:core-utils:compileJava`, the investigation is broader...
          
          Your output should look like this:
          
          ```
          #### Key findings
          
          * The build suffers from two distinct types of caching problems: volatile inputs (tasks re-running in the same location) and non-relocatability (tasks re-running in a new location).
          * The task `:core-utils:compileJava` re-executed in all experiments, suggesting it may have issues involving volatility, non-relocatable inputs, or both.
          * The task `:feature-login:compileJava` appears to have non-relocatable inputs since running the build from different directories caused it to re-execute, making it another key target for optimization.
          
          #### Recommendation
          
          The top priority should be a thorough investigation of the `:core-utils:compileJava` and `:feature-login:compileJava` tasks. Begin by addressing the volatile inputs identified in Experiment 1 and 2, as these issues often require more in-depth code changes. Afterward, address the non-relocatable inputs identified by Experiment 3 ensuring all file paths are relative. Fixing these core tasks will have the most significant impact on build performance and reliability.
          ```
          
          ---
          
          Now, analyze the following summaries and generate the report as instructed:
          
          Experiment 1 analysis:
          
          ```
          ${{ steps.summarize-exp1.outputs.summary }}
          
          Experiment 2 analysis:
          
          ```
          ${{ steps.summarize-exp2.outputs.summary }}
          ```
          
          Experiment 3 analysis:
          
          ```
          ${{ steps.summarize-exp3.outputs.summary }}
          ```
    - name: Capture results
      shell: bash
      env:
        WORKFLOW_NAME: ${{ github.workflow }}
        SUMMARY_FILE: ${{ runner.temp }}/experiments-summary.md
        EXP1_SUMMARY: ${{ steps.summarize-exp1.outputs.summary }}
        EXP1_EXECUTED_TASKS: ${{ steps.fetch-results.outputs.exp1-executed-tasks }}
        EXP2_SUMMARY: ${{ steps.summarize-exp2.outputs.summary }}
        EXP2_EXECUTED_TASKS: ${{ steps.fetch-results.outputs.exp2-executed-cacheable-tasks }}
        EXP3_SUMMARY: ${{ steps.summarize-exp3.outputs.summary }}
        EXP3_EXECUTED_TASKS: ${{ steps.fetch-results.outputs.exp3-executed-cacheable-tasks }}
        FINDINGS_SUMMARY: ${{ steps.summarize-findings.outputs.summary }}
      run: |
        write_summary() {
          local experiment_number summary executed_tasks
          experiment_number="$1"
          summary="$2"
          executed_tasks="$3"
        
          echo "## Experiment $experiment_number" >> $SUMMARY_FILE
          if [[ -n "$summary" ]]; then
            echo "$summary" >> $SUMMARY_FILE
          elif [[ "$executed_tasks" == "0" ]]; then
            echo "This experiment completed successfully, so no summary was generated." >> $SUMMARY_FILE
          else
            echo "This experiment didn't yield any results. The job may have failed." >> $SUMMARY_FILE
          fi
        }
        
        echo "# $WORKFLOW_NAME Experiments Summary" >> $SUMMARY_FILE
        
        write_summary 1 "$EXP1_SUMMARY" "$EXP1_EXECUTED_TASKS"
        write_summary 2 "$EXP2_SUMMARY" "$EXP2_EXECUTED_TASKS"
        write_summary 3 "$EXP3_SUMMARY" "$EXP3_EXECUTED_TASKS"
        
        echo "## Conclusion" >> $SUMMARY_FILE
        echo "$FINDINGS_SUMMARY" >> $SUMMARY_FILE
        
        cat $SUMMARY_FILE >> $GITHUB_STEP_SUMMARY
    - name: Archive experiment summary
      uses: actions/upload-artifact@v4
      with:
        name: experiments-summary
        path: ${{ runner.temp }}/experiments-summary.md
